#!/bin/bash

###
# usbkey-ctl-osx
# USB Key based SSH key management (MacOSX version)
#
# AUTHORS
#   Chibuzo Nwakama <cnwakama@bioneos.com>
#   Steven Davis <sgdavis@bioneos.com> 
#   Bio::Neos, Inc. <http://bioneos.com/>
#
# LICENSE
# Permission is hereby granted, free of charge, to any person obtaining a copy 
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# parameter 1 - inserted/removed string and 2 - name of disk (disk2s1, disk3s1, etc) 

# Constants
debug=0
mount_point=$(diskutil info ${2} | grep 'Mount Point' | cut -c30-)
usbkey_root="~/Library/usbkey/"
usbkey_setup="osx-setup.sh"
usbkey_image="osx.sparseimage"
usbkey_keyfile="key"
alias lockscreen='/System/Library/CoreServices/Menu\ Extras/User.menu/Contents/Resources/CGSession -suspend'
user=$(id -un)

# Key lifespan (in minutes)
timeout=720

logger -t usbkey "Executing 'usbkey-ctl $1' for $user [$2]"

# Determine operating mode
case "$1" in
  # Process when usbkey is removed:
  # 1) Look for ${userhome}/INSERTED
  #   If missing: 
  # exit immediately
  #   If exists:
  # 1) Find the running X desktop
  # 2) lock screen (desktop specific)
  # 3) clear all keys from ssh-agent 
removed)
    # Look for insertion hint
    if [[ ! -f ${usbkey_root}/INSERTED ]]; then
      logger -t usbkey "USBkey removed, but no insertion hint present. Exiting without clearing/locking..."
      exit
    else
      rm ${usbkey_root}/INSERTED
    fi
 

    # Lock the screen appropriately
    lockscreen
    

    # Clear out the ssh-agent keys
    logger -t usbkey "Removing all SSH identities from the agent for ${user}..."
    ssh-add -D 
  ;;
  # Process to when usbkey is inserted:
  #   1) find user running the current X session (above)
  #   First run: 
  #     1) setup script
  #     2) remove setup script
  #     Continue with a normal run...
  #   Normal run:
  #     1) mount usbkey media
  #     2) decrypt LUKS device 
  #       If successful:
  #     3) mount decrypted image
  #     4) add all keys from decrypted image
  #     5) umount decrypted image
  #     6) close LUKS device
  #       Finally:
  #     7) unmount / eject usbkey
  inserted)
    # Already mounted in MacOSX
    # Mount usbkey media

    # Determine if we need to setup this USBkey
    if [[ -f ${mount_point}/${usbkey_setup} ]]; then
      if [ $debug -eq 1 ]; then 
        logger -t usbkey "[DEBUG] USBkey inserted. Running first time setup script..."
      fi
      ${mount_point}/${usbkey_setup} 
      if [[ $? -ne 0 ]]; then
        logger -t usbkey "Setup for new USBkey failed..."
        exit 1
      else
        logger -t usbkey "Setup for new USBkey completed successfully..."
        rm ${mount_point}/${usbkey_setup} because it being ran on the usb itself
      fi
    fi
    

    # Decrypt the SPARSE image (using the keyfile)
    printf '' | hdiutil attach -stdinpass osx.sparseimage 

    #hdiutil create -stdinpass -attach -encryption AES-256 -type SPARSE -fs HFS+J -volname usbkey -size 100m "osx"

    # Unlock only if a successful decryption occurred
    if [[ -f /Volume/usbkey ]]
    then
      # Begin SSH key management
      logger -t usbkey "Found approved USBkey for ${user}..."
      
      count=0
      for key in `ls ${mount_point}/image/*_rsa`
      do
        logger -t usbkey "Adding SSH identity '$key' for '$user' [${timeout} min limit]..."
	ssh-add -t ${timeout} \$key
        count=$((count+1))
        if [ $debug -eq 1 ]; then
          logger -t usbkey "[DEBUG] cmd: 'ssh-add -t ${timeout} \$key'"
          eval_out=`'ssh-agent'`
          logger -t usbkey "[DEBUG] ssh-agent: $eval_out"
          ident_out=`'ssh-add -l' | tr '\n' ';'`
          logger -t usbkey "[DEBUG] ssh-agent identities: $ident_out"
        fi
      done
      # Unmount and close the device
      logger -t usbkey "Unmounting / closing encrypted device..."
      hdiutil eject /Volumes/usbkey/

      # Create insertion hint
      touch ${usbkey_root}/INSERTED

    else
      logger -t usbkey "USBkey device inserted, but keyfile for ${user} failed to decrypt!!"
    fi
    
    # For additional safety, this device will be ejected if the root of the
    # user has a file named EJECT present in 'usbkey_root'. Delete this file
    # if you need to operate on the USB device for some reason.
    if [ -f "${usbkey_root}/EJECT" ]; then
      # Unmount temp mount point
      diskutil unmount ${mount_point}
      # Eject device (also prevents automount by file manager)
      # NOTE: we are assuming the device name will be consistent to current
      #   naming as a kernel device (sdXY)
      #device=$(2)
      logger -t usbkey "Ejecting ${mount_point}..."
      diskutil eject ${mount_point}
    fi
  ;;
esac
